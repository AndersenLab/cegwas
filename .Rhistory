install.packages(c("ggplot2","dplyr","tidyr","data.table","grid","foreach","doMC","iterators","knitr"))
library(dplyr)
library(ggplot2)
library(tidyr)
library(data.table)
library("data.table", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
install.packages("chron")
library("data.table", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
detach("package:data.table", unload=TRUE)
install.packages(c("ggplot2","dplyr","tidyr","data.table","grid","foreach","doMC","iterators","knitr","chron","devtools"))
install.packages(c("ggplot2", "dplyr", "tidyr", "data.table",
;
install.packages("devtools")
source("~/Dropbox/Andersenlab/WormReagents/Variation/Andersen_VCF/read_vcf.R") # Get snpeff function
snpeff(region="I:1-10000")
setwd("~/Dropbox/AndersenLab/RCode/GWAS/cegwas/")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/whole_genome_kinship.Rdata")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/fill_error.Rda")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/124strain_5perc-MAF_imputed_SNPs.Rda")
library(devtools)
use_data(kinship,snps,fill_error, internal = TRUE)
devtools::load_all(".")
install.packages("doParallel")
load_all()
devtools::load_all(".")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/124strain_5perc-MAF_imputed_SNPs.Rda")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/whole_genome_kinship.Rdata")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/cegwas/data/fill_error.Rda")
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/Data/Combined_Processed_GWAS_Phenotypes.Rda")
View(gwas)
load("/Users/Stefan/Dropbox/AndersenLab/RCode/GWAS/Data/GenomicTraits/CleanedTransposons_resids.Rda")
data <- pheno6
traits <- data[[1]]
x <- as.matrix(data)[[2]]
x <- data.frame(x[,colSums(is.na(x))<(nrow(x))]) # remove NA strains
x <- as.matrix(data)[[2]]
x <- data.frame(x[,colSums(is.na(x))<(nrow(x))]) # remove NA strains
x <- t(t(x)) # convert back to matrix
x <- apply(x, 2, as.numeric)
View(x)
y <- snps
z <- kinship
View(z)
View(kinship)
y <- snps
z <- kinship
View(z)
test <- list(pheno6[[1]][1:4,], pheno6[[2]][1:4,])
pheno6[[1]]
test <- list(pheno6[[1]][1:4], pheno6[[2]][1:4,])
gwas_mappings <- function(data){
traits <- data[[1]]
x <- as.matrix(data)[[2]]
x <- data.frame(x[,colSums(is.na(x))<(nrow(x))]) # remove NA strains
x <- t(t(x)) # convert back to matrix
x <- apply(x, 2, as.numeric)
y <- snps
z <- kinship
x <- x[,colnames(x)%in%colnames(z)]
nodes <- detectCores()
cl <- makeCluster(nodes)
registerDoParallel(cl)
#run emma on all elements i, in list test
system.time(df <- foreach(i = iter(x, by = 'row')) %dopar% {
i <- t(i)
i <- na.omit(i)
i <- t(i)
y1 <- y[,colnames(y)%in%colnames(i)]
z1 <- z[row.names(z)%in%colnames(i),colnames(z)%in%colnames(i)]
y1 <- y1[rowSums(y1) >= ncol(y1)*.05,]
y1 <- y1[rowSums(y1) <= ncol(y1)*.95,]
error.fill1 <- lapply(fill_error, function(x){
temp <- x[1:nrow(y1),]
})
i <- i[,colnames(i)%in%colnames(y1)]
marks <- stringr::str_split_fixed(row.names(y1), pattern = "_", n = 2)
dfmark <- data.frame(SNPs = row.names(y1), chr = marks[,1], pos = as.numeric(marks[,2]), MAF = rowSums(y1)/ncol(y1), nsnps = rep(nrow(y1)))
emma.plow <- tryCatch({
emma.REML.t(i, y1, z1);
}, error = function(e){
return(error.fill1)
})
emma.plow <- data.frame(emma.plow, dfmark)
return(emma.plow)
})
stopCluster(cl)
######################### combine mappings and add trait column
for(i in 1:length(df)){
df[[i]] <- data.frame(df[[i]], traits[i])
}
#### save chunks of df prior to splitting by significance
temp <- df[c(1:length(df))]
save(temp, file = "RAW_EMMA_OUTPUT_GWAS.Rda")
df <- lapply(df, function(x){
if(is.infinite(min(x$ps, na.rm=T)) == F){
return(x)
}
})
df[sapply(df, is.null)] <- NULL
sigMAPS <- list()
for(i in 1:length(df)){
if(-log10(min(df[[i]]$ps)) > -log10(.05/nrow(df[[i]]))){
print(unique(as.character(df[[i]]$trait)))
print(-log10(min(df[[i]]$ps)) )
sigMAPS[[i]] <- df[[i]]
}else{
print(unique(as.character(df[[i]]$trait)))
print(-log10(min(df[[i]]$ps)) )
print("NOT SIG")
}
}
Mappings <- rbindlist(sigMAPS)
return(Mappings)
}
maps <- gwas_mappings(test)
maps <- gwas_mappings(test, fill_error = fill_error)
gwas_mappings <- function(data, fill_error){
traits <- data[[1]]
x <- as.matrix(data)[[2]]
x <- data.frame(x[,colSums(is.na(x))<(nrow(x))]) # remove NA strains
x <- t(t(x)) # convert back to matrix
x <- apply(x, 2, as.numeric)
y <- snps
z <- kinship
x <- x[,colnames(x)%in%colnames(z)]
nodes <- detectCores()
cl <- makeCluster(nodes)
registerDoParallel(cl)
#run emma on all elements i, in list test
system.time(df <- foreach(i = iter(x, by = 'row')) %dopar% {
i <- t(i)
i <- na.omit(i)
i <- t(i)
y1 <- y[,colnames(y)%in%colnames(i)]
z1 <- z[row.names(z)%in%colnames(i),colnames(z)%in%colnames(i)]
y1 <- y1[rowSums(y1) >= ncol(y1)*.05,]
y1 <- y1[rowSums(y1) <= ncol(y1)*.95,]
error.fill1 <- lapply(fill_error, function(x){
temp <- x[1:nrow(y1),]
})
i <- i[,colnames(i)%in%colnames(y1)]
marks <- stringr::str_split_fixed(row.names(y1), pattern = "_", n = 2)
dfmark <- data.frame(SNPs = row.names(y1), chr = marks[,1], pos = as.numeric(marks[,2]), MAF = rowSums(y1)/ncol(y1), nsnps = rep(nrow(y1)))
emma.plow <- tryCatch({
emma.REML.t(i, y1, z1);
}, error = function(e){
return(error.fill1)
})
emma.plow <- data.frame(emma.plow, dfmark)
return(emma.plow)
})
stopCluster(cl)
######################### combine mappings and add trait column
for(i in 1:length(df)){
df[[i]] <- data.frame(df[[i]], traits[i])
}
#### save chunks of df prior to splitting by significance
temp <- df[c(1:length(df))]
save(temp, file = "RAW_EMMA_OUTPUT_GWAS.Rda")
df <- lapply(df, function(x){
if(is.infinite(min(x$ps, na.rm=T)) == F){
return(x)
}
})
df[sapply(df, is.null)] <- NULL
sigMAPS <- list()
for(i in 1:length(df)){
if(-log10(min(df[[i]]$ps)) > -log10(.05/nrow(df[[i]]))){
print(unique(as.character(df[[i]]$trait)))
print(-log10(min(df[[i]]$ps)) )
sigMAPS[[i]] <- df[[i]]
}else{
print(unique(as.character(df[[i]]$trait)))
print(-log10(min(df[[i]]$ps)) )
print("NOT SIG")
}
}
Mappings <- rbindlist(sigMAPS)
return(Mappings)
}
maps <- gwas_mappings(test, fill_error = fill_error)
