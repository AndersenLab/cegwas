{
    "contents" : "#' Process Phenotype Data\n#'\n#' \\code{process_pheno} Process raw data file for GWAS mapping using \\code{gwas_mappings} function\n#'\n#' This function takes raw phenotype data and eliminates outlier strains with a modified version of \\code{bamf_prune} from the easysorter package.\n#' Additionally it eliminates any traits that have the same values for >95% of the strains (important for binary traits)\n#'\n#' @param data is a dataframe containing phenotype data. The first column should be names \\code{trait}\n#' all additional columns should be strains. One row corresponding to one trait for all strains.\n#' @return Outputs a list. The first element of the list is an ordered vector of traits. \n#' The second element of the list is a dataframe containing one column for each strain, with values corresponding to traits in element 1 for rows.\n#' @export\n#' \nprocess_pheno <- function(data){\n  \n  # identify an traits that only have 1 unique value\n  pheno <- data.frame(data.frame(data)[,1:ncol(data)], \n                      uniq = data.frame(uniq = c(apply(data.frame(data)[,2:ncol(data)], 1, function(x) length(unique(x))))),\n                      row.names = data$trait)\n  \n  # remove identified traits\n  phen <- pheno %>%\n    dplyr::filter(uniq != 1)%>%\n    dplyr::select(-uniq)\n  \n  # removes binary phenotypes where one phenotype is in less than 5% of strains\n  phen1 <- remove_lowFreq_phenotypes(phen)\n  # run modified version of bamf_prune from easy sorter package\n  # does the same thing as bamf_prune, just different input data structure\n  phen2 <- mod_bamf_prune(phen1)\n  # removes binary phenotypes where one phenotype is in less than 5% of strains\n  phen3 <- remove_lowFreq_phenotypes(phen2, wide = FALSE)\n  \n  # make into long formated data\n  phen4 <- phen3%>%\n    tidyr::spread(strain,value)\n  \n  # generate traits list\n  traits <- phen4$trait\n  \n  # remove trait column from phenotype data frame\n  phen5 <- data.frame(phen4) %>% \n    dplyr::select(-trait)\n  \n  # make phenotypes numeric\n  phen6 <- data.frame(lapply(phen5, function(x) as.numeric(as.character(x))))\n  \n  # generate list data structure to feed into mapping function\n  output <- list(traits, phen6)\n  \n  return(output)\n}\n\n# called functions\n# function to remove phenotypes with low frequencies (only important for binary traits)\nremove_lowFreq_phenotypes <- function(data, wide = TRUE){\n  \n  if(wide == T){\n    output <- data.frame(data)%>%\n      tidyr::gather(strain, value, -trait)%>% # make long\n      dplyr::group_by(trait)%>% # group\n      dplyr::mutate(nst = n(), # number strain per trait\n             nuniq = length(unique(value)))%>% # number of unique values\n      dplyr::mutate(u1 = ifelse(nuniq == 2, unique(value)[1], -9999), # if two unique values, add first unique value\n             u2 = ifelse(nuniq == 2, unique(value)[2], -9999))%>% # if two unique values, add second unique value\n      dplyr::mutate(count1 = ifelse(u1 != -9999 & value == unique(value)[1], 1, 0), # add 1 if value = first unique (requires only 2 uniques)\n             count2 = ifelse(u2 != -9999 & value == unique(value)[2], 1, 0))%>% # add 1 if value = second unique (requires only 2 uniques)\n      dplyr::mutate(freq1 = sum(count1)/nst, # get frequency of values from traits where there are only two unique trait values\n             freq2 = sum(count2)/nst)%>% # get frequency of values from traits where there are only two unique trait values\n      dplyr::mutate(cuts = ifelse(u1 != -9999 & \n                             u2 != -9999 & \n                             (freq1 < .05 | freq1 > .95), 1,0))%>% # add ID for traits that have less than 5% of strains with one trait\n      dplyr::filter(cuts != 1)%>% # remove traits identified by cut1\n      dplyr::select(trait, strain, value) # remove columns used for cut\n  } \n  else\n  {\n    output <- data.frame(data)%>%\n      dplyr::group_by(trait)%>% # group\n      dplyr::mutate(nst = n(), # number strain per trait\n             nuniq = length(unique(value)))%>% # number of unique values\n      dplyr::mutate(u1 = ifelse(nuniq == 2, unique(value)[1], -9999), # if two unique values, add first unique value\n             u2 = ifelse(nuniq == 2, unique(value)[2], -9999))%>% # if two unique values, add second unique value\n      dplyr::mutate(count1 = ifelse(u1 != -9999 & value == unique(value)[1], 1, 0), # add 1 if value = first unique (requires only 2 uniques)\n             count2 = ifelse(u2 != -9999 & value == unique(value)[2], 1, 0))%>% # add 1 if value = second unique (requires only 2 uniques)\n      dplyr::mutate(freq1 = sum(count1)/nst, # get frequency of values from traits where there are only two unique trait values\n             freq2 = sum(count2)/nst)%>% # get frequency of values from traits where there are only two unique trait values\n      dplyr::mutate(cuts = ifelse(u1 != -9999 & \n                             u2 != -9999 & \n                             (freq1 < .05 | freq1 > .95), 1,0))%>% # add ID for traits that have less than 5% of strains with one trait\n      dplyr::filter(cuts != 1)%>% # remove traits identified by cut1\n      dplyr::select(trait, strain, value) # remove columns used for cut\n  }\n  \n  return(output)\n}\n\n# modified version of bamf_prune\n# works the same as from the easysorter package, but with different input format\nmod_bamf_prune <- function(data){\n  \n  napheno <- data[is.na(data$value), ] %>%\n    dplyr::mutate(bamfoutlier1 = NA, bamfoutlier2 = NA, bamfoutlier3 = NA)\n  \n  datawithoutliers <- data %>%\n    \n    # Filter out all of the wash and/or empty wells\n    \n    dplyr::filter(!is.na(strain)) %>%\n    \n    # Group on condition and trait, the, calculate the first and third\n    # quartiles for each of the traits\n    \n    dplyr::group_by(trait) %>%\n    dplyr::summarise(iqr = IQR(value, na.rm = TRUE),\n                     q1 = quantile(value, probs = .25, na.rm = TRUE),\n                     q3 = quantile(value, probs = .75,\n                                   na.rm = TRUE)) %>%\n    \n    # Add a column for the boundaries of each of the bins\n    \n    dplyr::mutate(cut1h = q3 + (iqr * 2),\n                  cut1l =q1 - (iqr * 2),\n                  cut2h = q3 + (iqr * 3),\n                  cut2l =q1 - (iqr * 3),\n                  cut3h = q3 + (iqr * 4),\n                  cut3l =q1 - (iqr * 4),\n                  cut4h = q3 + (iqr * 5),\n                  cut4l =q1 - (iqr * 5),\n                  cut5l = q1 - (iqr * 7),\n                  cut5h = q3 + (iqr * 7),\n                  cut6l = q1 - (iqr * 10),\n                  cut6h = q3 + (iqr * 10)) %>%\n    \n    # Join the bin boundaries back to the original data frame\n    \n    dplyr::left_join(data, ., by=c(\"trait\")) %>%\n    \n    # Add columns tallying the total number of points in each of the bins\n    \n    dplyr::mutate(onehs = ifelse( cut2h > value & value >= cut1h,\n                                  1, 0),\n                  onels = ifelse( cut2l < value & value <= cut1l,\n                                  1, 0),\n                  twohs = ifelse( cut3h > value & value >= cut2h,\n                                  1, 0),\n                  twols = ifelse( cut3l < value & value <= cut2l,\n                                  1, 0),\n                  threehs = ifelse(cut4h > value & value >= cut3h,\n                                   1, 0),\n                  threels = ifelse(cut4l < value & value <= cut3l,\n                                   1, 0),\n                  fourhs = ifelse(cut5h > value &  value >= cut4h,\n                                  1, 0),\n                  fourls = ifelse(cut5l < value &  value <= cut4l,\n                                  1, 0),\n                  fivehs = ifelse(cut6h > value & value >= cut5h,\n                                  1, 0),\n                  fivels = ifelse(cut6l < value & value <= cut5l,\n                                  1, 0),\n                  sixhs = ifelse(value >= cut6h, 1, 0),\n                  sixls = ifelse(value <= cut6l, 1, 0)) %>%\n    \n    # Group on condition and trait, then sum the total number of data points\n    # in each of the IQR multiple bins\n    \n    dplyr::group_by(trait) %>%\n    dplyr::mutate(s1h = sum(onehs, na.rm = TRUE),\n                  s2h = sum(twohs, na.rm = TRUE),\n                  s3h = sum(threehs, na.rm = TRUE),\n                  s4h = sum(fourhs, na.rm = TRUE),\n                  s5h = sum(fivehs, na.rm = TRUE),\n                  s1l = sum(onels, na.rm = TRUE),\n                  s2l = sum(twols, na.rm = TRUE),\n                  s3l = sum(threels, na.rm = TRUE),\n                  s4l = sum(fourls, na.rm = TRUE),\n                  s5l = sum(fivels, na.rm = TRUE),\n                  s6h = sum(sixhs, na.rm = TRUE),\n                  s6l = sum(sixls, na.rm = TRUE))%>%\n    \n    # Group on condition and trait, then check to see if the number of\n    # points in each bin is more than 5% of the total number of data points\n    \n    dplyr::group_by(trait) %>%\n    dplyr::mutate(p1h = ifelse(sum(onehs, na.rm = TRUE) / n() >= .05,1,0),\n                  p2h = ifelse(sum(twohs, na.rm = TRUE) / n() >= .05,1,0),\n                  p3h = ifelse(sum(threehs, na.rm = TRUE) / n() >= .05,1,0),\n                  p4h = ifelse(sum(fourhs, na.rm = TRUE) / n() >= .05,1,0),\n                  p5h = ifelse(sum(fivehs, na.rm = TRUE) / n() >= .05,1,0),\n                  p6h = ifelse(sum(sixhs, na.rm = TRUE) / n() >= .05,1,0),\n                  p1l = ifelse(sum(onels, na.rm = TRUE) / n() >= .05,1,0),\n                  p2l = ifelse(sum(twols, na.rm = TRUE) / n() >= .05,1,0),\n                  p3l = ifelse(sum(threels, na.rm = TRUE) / n() >= .05,1,0),\n                  p4l = ifelse(sum(fourls, na.rm = TRUE) / n() >= .05,1,0),\n                  p5l = ifelse(sum(fivels, na.rm = TRUE) / n() >= .05,1,0),\n                  p6l = ifelse(sum(sixls,\n                                   na.rm = TRUE) / n() >= .05,1,0)) %>%\n    \n    # Count the number of observations in each condition/trait combination\n    \n    dplyr::mutate(numst = n()) %>%\n    \n    # Group on condition and trait, then filter out NAs in any of the added\n    # columns\n    \n    dplyr::group_by(trait) %>%\n    dplyr::filter(!is.na(trait), !is.na(value), !is.na(iqr), !is.na(q1),\n                  !is.na(q3), !is.na(cut1h), !is.na(cut1l), !is.na(cut2h),\n                  !is.na(cut2l), !is.na(cut3h), !is.na(cut3l),\n                  !is.na(cut4h), !is.na(cut4l), !is.na(cut5l),\n                  !is.na(cut5h), !is.na(cut6l), !is.na(cut6h),\n                  !is.na(onehs), !is.na(onels), !is.na(twohs),\n                  !is.na(twols), !is.na(threehs), !is.na(threels),\n                  !is.na(fourhs), !is.na(fourls), !is.na(fivehs),\n                  !is.na(fivels), !is.na(sixhs), !is.na(sixls),\n                  !is.na(s1h), !is.na(s2h), !is.na(s3h), !is.na(s4h),\n                  !is.na(s5h), !is.na(s1l), !is.na(s2l), !is.na(s3l),\n                  !is.na(s4l), !is.na(s5l), !is.na(s6h), !is.na(s6l),\n                  !is.na(p1h), !is.na(p2h), !is.na(p3h), !is.na(p4h),\n                  !is.na(p5h), !is.na(p6h), !is.na(p1l), !is.na(p2l),\n                  !is.na(p3l), !is.na(p4l), !is.na(p5l), !is.na(p6l),\n                  !is.na(numst)) %>%\n    \n    # Add three columns stating whether the observation is an outlier\n    # based the three outlier detection functions below\n    \n    dplyr::ungroup() %>%\n    \n    dplyr::mutate(cuts = categorize1(.),\n                  cuts1 = categorize2(.),\n                  cuts2 = categorize3(.))\n  \n  \n  output <- datawithoutliers %>%\n    dplyr::rename(bamfoutlier1 = cuts, \n                  bamfoutlier2 = cuts1,\n                  bamfoutlier3 = cuts2)%>%\n    dplyr::filter(!bamfoutlier1 & !bamfoutlier2 & !bamfoutlier3)%>%\n    dplyr::select(trait, strain, value)\n  \n  return(output)\n}\n\ncategorize1 <- function(data) {\n  with(data,\n       (sixhs >= 1 & ( (s6h + s5h + s4h ) / numst) <= .05\n        & (s5h == 0 | s4h == 0))\n       | (sixls >= 1 & ( (s6l + s5l + s4l) / numst) <= .05\n          & (s5l == 0 | s4l == 0))\n  )\n}\n\n# If the 5 innermost bins are discontinuous by more than a 1 bin gap, the\n# observation is in the fifth bin (between 7 and 10x IQR outside the\n# distribution), and the four outermost bins make up less than 5% of the\n# population, mark the observation an outlier\n\ncategorize2 <- function(data) {\n  with(data,\n       ( ( ! ( (s5h >= 1 & s4h >= 1 & s3h >= 1 & s2h >= 1 & s1h >= 1)\n               | (s5h >= 1 & s3h >= 1 & s2h >= 1 & s1h >= 1)\n               | (s5h >= 1 & s4h >= 1 & s2h >= 1 & s1h >= 1)\n               | (s5h >= 1 & s4h >= 1 & s3h >= 1 & s1h >= 1)\n               | (s5h >= 1 & s4h >= 1 & s3h >= 1 & s2h >= 1)))\n         & (fivehs == 1 & ( (s6h + s5h + s4h + s3h) / numst) <= .05))\n       | ( ( ! ( (s5h >= 1 & s4l >= 1 & s3l >= 1 & s2l >= 1 & s1l >= 1)\n                 | (s5h >= 1 & s3l >= 1 & s2l >= 1 & s1l >= 1)\n                 | (s5h >= 1 & s4l >= 1 & s2l >= 1 & s1l >= 1)\n                 | (s5h >= 1 & s4l >= 1 & s3l >= 1 & s1l >= 1)\n                 | (s5h >= 1 & s4l >= 1 & s3l >= 1 & s2l >= 1)))\n           & (fivels == 1 & ( (s6l + s5l + s4l + s3l) / numst) <= .05))\n  )\n}\n\n# If the 4 innermost bins are discontinuous by more than a 1 bin gap, the\n# observation is in the fourth bin (between 5 and 7x IQR outside the\n# distribution), and the four outermost bins make up less than 5% of the\n# population, mark the observation an outlier\n\ncategorize3 <- function(data) {\n  with(data,\n       ( ( ! ( (s4h >= 1 & s3h >= 1 & s2h >= 1 & s1h >= 1)\n               | (s4h >= 1 & s2h >= 1 & s1h >= 1)\n               | (s4h >= 1 & s3h >= 1 & s1h >= 1)\n               | (s4h >= 1 & s3h >= 1 & s2h >= 1)))\n         & (fourhs == 1 & (s5h + s4h + s3h + s2h) / numst <= .05))\n       | ( ( ! ( (s4l >= 1 & s3l >= 1 & s2l >= 1 & s1l >= 1)\n                 | (s4l >= 1 & s2l >= 1 & s1l >= 1)\n                 | (s4l >= 1 & s3l >= 1 & s1l >= 1)\n                 | (s4l >= 1 & s3l >= 1 & s2l >= 1)))\n           & (fourls == 1 & (s5l + s4l + s3l + s2l) / numst <= .05))\n  )\n}",
    "created" : 1440101822984.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4207073910",
    "id" : "D2E6F3DF",
    "lastKnownWriteTime" : 1440102548,
    "path" : "~/Dropbox/AndersenLab/RCode/GWAS/cegwas/R/process_phenotypes.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}