{
    "contents" : "#' Calcule Variance Explained for Significant SNPs\n#'\n#' \\code{calculate_VE} calculates the variance explained (VE) for significant SNPs by using the \n#' the spearman rank correlation coefficient.\n#'\n#' This function requires three inputs, two of which are provided by the user and the other is loaded by the package.\n#'\n#' @param mapping_df the output from the \\code{gwas_mappings} function. User input\n#' @param snp_df genotype information for 124 wild isolates. Provided by package\n#' @param phenotype_df two element list. element 1 : traits. element 2: trait values with strains in columns\n#' with each row corresponding to trait in element 1\n#' @return Outputs a two element list that contains two dataframes. \n#' The first data frame is a processed mappings dataframe that contains the same columns\n#' as the output of \\code{gwas_mappings} with two additional columns. One that contains\n#' the bonferroni corrected p-value (BF) and another that contains an identifier 1,0 if \n#' the indicated SNP has a higher -log10 value than the bonferroni cut off or not, respectively\n#' The second data frame contains the variance explained data as well as all of the information from the first element.\n#' @export\n\ncalculate_VE <- function( mapping_df,\n                          snp_df = snps,\n                          phenotype_df ) {\n  \n  # mapping_df <- sig_maps\n  # snp_df <- snps\n  # phenotype_df <- test\n  \n    # format phenotypes\n    pheno <- phenotype_df[[2]]\n    row.names(pheno) <- phenotype_df[[1]]\n    pheno$trait <- phenotype_df[[1]]\n  \n  \n  Processed <- mapping_df %>%\n    dplyr::group_by( trait ) %>%\n    dplyr::mutate( BF = -log10(.05/n()) ) %>% #  add BF threshold\n    dplyr::group_by( trait ) %>%\n    dplyr::mutate( aboveBF = ifelse(log10p >= BF, 1, 0) ) %>% #  label SNPs as significant\n    dplyr::ungroup()\n  \n  ## Select SNPs above BF\n  snpsForVE <- Processed %>%\n    dplyr::filter( aboveBF == 1 ) %>%\n    dplyr::select( marker, trait )\n  \n  snpsForVE$trait <- as.character(snpsForVE$trait)\n  \n  ## Trim raw data and snp set to contain phenotypes and snps from BF mappings\n  \n  row.names(pheno) <- gsub(\"-\", \"\\\\.\", row.names(pheno))\n  pheno$trait <- gsub(\"-\", \"\\\\.\", pheno$trait) \n  \n  # Trim phenotypes and join to significant snps identified in mapping\n  rawTr <- pheno[ row.names(pheno) %in% snpsForVE$trait,] %>%\n    tidyr::gather( strain, value, -trait ) %>% # make long format\n    dplyr::left_join( ., snpsForVE, \n                      by = \"trait\" ) # join to significant SNPs from mapping dataframe\n  \n  # make columns factored by dplyr into characters to minimize warnings\n  rawTr$marker <- as.character(rawTr$marker)\n  rawTr$strain <- as.character(rawTr$strain)\n  \n  # Trim snps to only contain those that are significant from mappings\n  gINFO <- snp_df %>%\n    dplyr::mutate( marker = paste(CHROM, POS, sep = \"_\")) %>%\n    dplyr::filter( marker %in% snpsForVE$marker ) %>%\n    tidyr::gather( strain, allele, -marker, -CHROM, -POS) \n    \n  # make columns factored by dplyr into characters to minimize warnings\n  gINFO$marker <- as.character(gINFO$marker)\n  \n  # combine genotype data, phenotype data, and significant snps from mappnings\n  gINFO <- data.frame(gINFO) %>%\n    dplyr::left_join( ., snpsForVE, by= \"marker\") %>% # join significant snps with genotypes\n    dplyr::left_join( rawTr, ., by=c( \"trait\", \"strain\", \"marker\") ) # join to phenotypes\n  \n  # calculate variance explained using spearman correlation\n  cors <- gINFO %>%\n    # each significant snp contains genotype and phenotype information for all strains\n    # so group by both to calculate variance explained for each significant snp\n    dplyr::group_by( trait, marker ) %>% \n    # calculate correlation\n    dplyr::mutate( var.exp = cor(value, allele, use = \"pairwise.complete.obs\", method=\"spearman\")^2 )  \n  \n  # bring it all together, that :\n  # # # genotypes\n  # # # phenotypes\n  # # # correlations\n  # # # # # # # # # # # FOR ALL SIGNIFICANT SNPS\n  \n  CORmaps <- Processed %>%\n    dplyr::left_join( ., cors, by=c(\"trait\",\"marker\",\"CHROM\",\"POS\"), copy=TRUE )\n  \n  return( list(Processed, CORmaps) )\n}\n\n#' Find Peaks from GWAS Peaks\n#'\n#' \\code{find_peaks} Identifies QTL from GWAS mapping data set.\n#'\n#' This function identifies QTL by looking at SNPs above the bonferroni corrected p-value.\n#' If only one SNP passed the significance cutoff, then the confidence interval is defined\n#' as +/- \\code{CI_size} (number of SNPs; default 50) away from that SNP. If multiple SNPs \n#' are above the cutoff, the function asks if SNPs are within an arbitrary number of SNPs away\n#' \\code{snp_grouping} - default 200. If the significant SNPs are within this range, they are grouped into the same peak.\n#' If they are greater than this distance, then the peaks are considered unique. \n#' \n#' @param processed_mapping_df The first element of the output list from the \\code{calculate_VE} function.\n#' @param CI_size defines the size (in # SNPs) of confidence intervals. Default is 50 and is defined in more detail below.\n#' @param snp_grouping defines grouping of peaks. Defined further below, default is 200.\n#' @return Outputs a two element list that contains. \n#' First element - data frame containing all identified intervals\n#' Second element - list containing one element for each interval\n#' @export\n\nfind_peaks <- function( processed_mapping_df, \n                        CI_size = 50,\n                        snp_grouping = 200 ) {\n  \n  # processed_mapping_df <- Processed\n  # snp_grouping <- 200\n  # CI_size <- 50\n  \n  # # # IDENTIFY PEAKS\n  \n  # PHENOTYPES THAT HAVE SIGNIFICANT MAPPINGS\n  phenotypes <- as.character(unique(processed_mapping_df$trait))\n  \n  # INITIALIZE A LIST TO PUT INDIVIDUAL PHENOTYPE INTERVAL INFORMATION\n  intervals <- list()\n  \n  # LOOP THROUGH ALL UNIQUE PHENOTYPES\n  for( i in 1:length(phenotypes) ){\n    \n    print(paste(100*signif(i/length(phenotypes),3), \"%\",sep=\"\"))\n    \n    # PREP DATA FRAME FOR PEAK IDENTIFICATION\n    \n    PeakDF <- processed_mapping_df %>%\n      dplyr::filter( trait == phenotypes[i] ) %>%\n      dplyr::group_by( CHROM, trait ) %>%\n      dplyr::mutate( index = 1:n() ) %>% # SNP INDEX\n      dplyr::mutate( peaks = cumsum(aboveBF) ) %>% # IDENTIFY PEAKS\n      dplyr::filter( aboveBF == 1 )%>% # KEEP SNPS ABOVE BONFERRONI\n      dplyr::group_by( CHROM, trait) %>%\n      dplyr::mutate( nBF = n() ) %>% # COUNT NUMBER OF SNPS ABOVE BONFERRONI PER PHENOTYPE PER CHROMOSOME\n      dplyr::group_by( CHROM, trait ) %>% \n      dplyr::arrange( CHROM, POS ) # ARRANGE DATA BY CHROMOSOME AND POSITION\n    \n    # generate a SNP index for SNPs on each chromosome\n    SNPindex <- processed_mapping_df %>%\n      dplyr::filter( trait == phenotypes[i] ) %>%\n      dplyr::group_by( CHROM, trait ) %>%\n      dplyr::mutate( index = 1:n() )%>%\n      dplyr::distinct( CHROM, POS )%>%\n      dplyr::select( CHROM, POS, index )%>%\n      dplyr::filter( POS == min(POS) | POS == max(POS) )\n    \n    # FILTER COMPLETE DATA SET TO JUST LOOK AT ONE PHENOTYPE AT A TIME\n    findPks <- PeakDF %>%\n      dplyr::filter( trait == phenotypes[i] ) %>% \n      dplyr::group_by( CHROM ) %>% \n      dplyr::arrange( CHROM, POS )\n    \n    # IF ONLY ONE SNP PASSED SIGNIFICANCE THRESHOLD LABEL PEAK ID AS 1\n    if ( findPks$nBF == 1 & length(unique(findPks$CHROM) ) == 1 ){\n      \n      findPks$pID <- 1\n      \n      # PLUS / MINUS 50 SNPS FROM PEAK SNP DEFINES CONFIDENCE INTERVAL\n      findPks <- findPks %>%\n        dplyr::group_by( CHROM, pID, trait ) %>%\n        dplyr::mutate( start = min(index) - CI_size,\n                       end = max(index) + CI_size )\n      \n      for( k in 1:nrow(findPks) ){\n        \n        tSNPs <- SNPindex %>%\n          dplyr::filter( CHROM == findPks$CHROM[k] )\n        \n        if( findPks$start[k] < min(tSNPs$index) ){\n          \n          findPks$start[k] <- min(tSNPs$index)\n          \n        } else if( findPks$end[k] > max(tSNPs$index) ) {\n          \n          findPks$end[k] <- max(tSNPs$index)\n          \n        }\n      }\n      \n      # APPEND TO LIST\n      intervals[[i]] <- findPks %>%\n        dplyr::ungroup()\n      \n    } \n    else \n    {\n      # INITIALIZE PEAK ID COLUMN WITH 1'S :: GIVES YOU A STARTING POINT\n      findPks$pID <- 1\n      \n      # LOOP THROUGH ROWS FOR EACH PHENOTYPE CORRESPONDING TO SNPS ABOVE BONFERRONI CORRECTION\n      # START AT ROW 2 BECAUSE THERE WILL ALWAYS BE AT LEAST 1 UNIQUE PEAK\n      for( j in 2:nrow(findPks) ){\n        \n        # IF \n        # SNP INDEX IS WITHIN A CERTAIN RANGE (snp_grouping) OF SNP FROM PREVIOUS ROW\n        # AND\n        # ON THE SAME CHROMOSOME AS SNP FROM PREVIOUS ROW\n        # # # # CONSIDER THEM TO BE THE SAME PEAK\n        \n        # IF THE ABOVE CONDITIONS ARE NOT MET\n        # ADD 1 TO THE PEAK ID (i.e. IDENTIFY AS A NEW PEAK)\n        findPks$pID[j] <- ifelse( abs(findPks$index[j] - findPks$index[j-1]) < snp_grouping &\n                                    findPks$CHROM[j] == findPks$CHROM[j-1],\n                                  findPks$pID[j-1],\n                                  findPks$pID[j-1]+1)\n      }\n      \n      # PLUS / MINUS 50 SNPS FROM PEAK SNP DEFINES CONFIDENCE INTERVAL\n      findPks <- findPks %>%\n        dplyr::group_by( CHROM , pID, trait) %>%\n        dplyr::mutate(start = min(index) - CI_size,\n                      end = max(index) + CI_size)\n      \n      \n      for( k in 1:nrow(findPks) ){\n        \n        tSNPs <- SNPindex %>%\n          dplyr::filter( CHROM == findPks$CHROM[k] )\n        \n        if( findPks$start[k] < min(tSNPs$index) ){\n          \n          findPks$start[k] <- min(tSNPs$index)\n          \n        } else if( findPks$end[k] > max(tSNPs$index) ) {\n          \n          findPks$end[k] <- max(tSNPs$index)\n          \n        }\n      } \n      \n      \n    }\n    \n    # APPEND TO LIST\n    intervals[[i]] <- findPks %>% \n      dplyr::ungroup()\n    \n  }\n  # BIND GENERATED LIST TOGETHER \n  intervalDF <- data.table::rbindlist(intervals)\n  \n  return( list(intervalDF, intervals) )\n}\n\n#' Identify confidence intervals associated with QTL. \n#'\n#' \\code{identify_CI} Identifies confidence intervals for identified QTL\n#'\n#' Function to combine all of the previously generated data into one data frame. Converts SNP index confidence intervals\n#' into genomic position confidence intervals.\n#' \n#' @param processed_mapping_df The first element of the \\code{calculate_VE} function output\n#' @param peak_df The first element of the \\code{find_peaks} function output\n#' @param peak_list The second element of the \\code{find_peaks} function output \n#' @param correlation_df The second element of the \\code{calculate_VE} function output\n#' @return Outputs processed mapping dataframe that contains original mapping dataframe with appended information for significant SNPs only, including:\n#' variance explained, confidence interval information, genotype information\n#' @export\n\nidentify_CI <- function( processed_mapping_df, \n                         peak_df, \n                         peak_list, \n                         correlation_df ) {\n  \n  # processed_mapping_df <- Processed\n  # peak_df = intervalDF \n  # peak_list = intervals\n  # correlation_df = CORmaps \n  \n  # FILTER COMPLETE MAPPING SET TO ONLY CONTAIN INTERVAL INDICIES TO SAVE COMPUTATIONAL TIME BELOW\n  Pos_Index_Reference  <- processed_mapping_df %>%\n    dplyr::group_by( CHROM, trait ) %>%\n    dplyr::mutate( index = 1:n() ) %>%\n    dplyr::mutate( peaks = cumsum(aboveBF) ) %>%\n    dplyr::select( trait, CHROM, POS, index ) %>%\n    dplyr::filter( index %in% c(unique(peak_df$start), unique(peak_df$end)) ) %>%\n    dplyr::ungroup()\n  \n  Pos_Index_Reference$trait <- as.character(Pos_Index_Reference$trait)\n  \n  # INITIALIZE LIST TO APPEND INTERVAL POSITION DATA FOR EACH PHENOTYPE\n  interval_positions <- list()\n  \n  # LOOP THROUGH UNIQUE PHENOTYPES TO LINK CONFIDENCE INTERVALS IN INDEX FORM TO POSITION FORM\n  for( i in 1:length(peak_list)){\n    \n    print(paste(100*signif(i/length(peak_list),3), \"%\",sep=\"\"))\n    \n    peak_list[[i]]$trait <- as.character(peak_list[[i]]$trait)\n    \n    # FILTER TO LOOK AT ONE PHENOTYPE AT A TIME\n    # FILTER APPROPRIATE INTERVAL INDICIES AND CHROMOSOMES FOR THAT PHENOTYPE\n    trait_i <- unique(peak_list[[i]]$trait)\n    index_i <- c(peak_list[[i]]$start, peak_list[[i]]$end) \n    CHROM_i <- peak_list[[i]]$CHROM\n    \n    PKpos <- data.frame(Pos_Index_Reference) %>%\n      dplyr::filter(trait == trait_i &\n                    index %in% index_i &\n                    CHROM %in%  CHROM_i) %>%\n      # JOIN POSITION INFORMATION TO PHENOTYPE PEAK INFORMATION\n      dplyr::left_join( ., peak_list[[i]], by= c(\"trait\",\"CHROM\") )%>%\n      # YOU WILL GET UNWANTED SNP INDEX INFORMATION IN SITUATIONS WHERE YOU HAVE MULTIPLE PEAKS \n      # ELIMINATE THOSE BY MATCHING START AND END FROM INDEX DATAFRAME TO INDEX FROM POSITION DATAFRAME\n      # FIRST FLAG\n      dplyr::mutate(issues = ifelse(start == index.x | end == index.x, 1, 0))%>%\n      # THEN REMOVE\n      dplyr::filter(issues != 0)%>%\n      # SELECT COLUMNS OF INTEREST\n      dplyr::select(trait, CHROM, POS.x, POS.y, pID, log10p, index.x, index.y, start, end)%>%\n      # GROUP BY PEAK IDS ORIGINALLY PRESENT IN INDEX DATAFRAME\n      dplyr::group_by(CHROM, pID) %>%\n      # GENERATE COLUMNS TO WITH INTERVAL POSITIONS AND PEAK POSITIONS\n      dplyr::mutate(startPOS = min(POS.x),\n                    peakPOS = POS.y,\n                    endPOS = max(POS.x)) %>%\n      # ELIMINATE REDUNDANT DATA\n      dplyr::distinct(trait, CHROM, pID, peakPOS) %>%\n      # SELECT COLUMNS OF NTEREST\n      dplyr::select(trait, CHROM, POS = POS.y, startPOS, peakPOS, endPOS, peak_id = pID)\n    \n    # APPEND TO LIST\n    interval_positions[[i]] <- PKpos\n  }\n  \n  # BIND EVERYTHING\n  interval_pos_df <- data.frame(data.table::rbindlist(interval_positions)) %>%\n    # CALCULATE INTERVAL SIZE\n    dplyr::mutate(interval_size = endPOS - startPOS)\n  \n  # JOIN INTERVAL POSITIONS TO DATA FRAME CONTAINING CORRELATION INFORMATION AND PHENOTYPE INFORMATION\n  Final_Processed_Mappings <- dplyr::left_join( correlation_df, interval_pos_df, \n                                         by = c(\"trait\", \"CHROM\", \"POS\"),\n                                         copy = TRUE )\n  \n  return(Final_Processed_Mappings)\n}\n\n#' Fully process GWAS mapping output\n#'\n#' \\code{process_mappings} takes \\code{gwas_mappings} output and calculates variance explained and\n#' identifies peaks and associated confidence intervals\n#'\n#' This function combines \\code{calculate_VE}, \\code{find_peaks}, and \\code{identify_CI} into one function when intermediate dataframes are not wanted\n#' \n#' @param mapping_df Output from \\code{gwas_mappings} function\n#' @param snp_df SNP dataframe that is part of this package\n#' @param phenotype_df phenotype data frame generated by \\code{process_pheno}. two element list. element 1 : traits. element 2: trait values with strains in columns\n#' with each row corresponding to trait in element 1\n#' @param CI_size defines the size (in # SNPs) of confidence intervals. Default is 50 and is defined in more detail below.\n#' @param snp_grouping defines grouping of peaks. Defined further below, default is 200.\n#' @return Outputs processed mapping dataframe that contains original mapping dataframe with appended information for significant SNPs only, including:\n#' variance explained, confidence interval information, genotype information\n#' @export\n\n\nprocess_mappings <- function(mapping_df,\n                             snp_df = snps,\n                             phenotype_df,\n                             CI_size = 50,\n                             snp_grouping = 200){\n  \n  # format phenotypes\n  pheno <- phenotype_df[[2]]\n  row.names(pheno) <- phenotype_df[[1]]\n  pheno$trait <- phenotype_df[[1]]\n  \n  \n  Processed <- mapping_df %>%\n    dplyr::group_by( trait ) %>%\n    dplyr::mutate( BF = -log10(.05/n()) ) %>% #  add BF threshold\n    dplyr::group_by( trait ) %>%\n    dplyr::mutate( aboveBF = ifelse(log10p >= BF, 1, 0) ) %>% #  label SNPs as significant\n    dplyr::ungroup()\n  \n  ## Select SNPs above BF\n  snpsForVE <- Processed %>%\n    dplyr::filter( aboveBF == 1 ) %>%\n    dplyr::select( marker, trait )\n  \n  snpsForVE$trait <- as.character(snpsForVE$trait)\n  \n  ## Trim raw data and snp set to contain phenotypes and snps from BF mappings\n  \n  row.names(pheno) <- gsub(\"-\", \"\\\\.\", row.names(pheno))\n  pheno$trait <- gsub(\"-\", \"\\\\.\", pheno$trait) \n  \n  # Trim phenotypes and join to significant snps identified in mapping\n  rawTr <- pheno[ row.names(pheno) %in% snpsForVE$trait,] %>%\n    tidyr::gather( strain, value, -trait ) %>% # make long format\n    dplyr::left_join( ., snpsForVE, \n                      by = \"trait\" ) # join to significant SNPs from mapping dataframe\n  \n  # make columns factored by dplyr into characters to minimize warnings\n  rawTr$marker <- as.character(rawTr$marker)\n  rawTr$strain <- as.character(rawTr$strain)\n  \n  # Trim snps to only contain those that are significant from mappings\n  gINFO <- snp_df %>%\n    dplyr::mutate( marker = paste(CHROM, POS, sep = \"_\")) %>%\n    dplyr::filter( marker %in% snpsForVE$marker ) %>%\n    tidyr::gather( strain, allele, -marker, -CHROM, -POS) \n  \n  # make columns factored by dplyr into characters to minimize warnings\n  gINFO$marker <- as.character(gINFO$marker)\n  \n  # combine genotype data, phenotype data, and significant snps from mappnings\n  gINFO <- data.frame(gINFO) %>%\n    dplyr::left_join( ., snpsForVE, by= \"marker\") %>% # join significant snps with genotypes\n    dplyr::left_join( rawTr, ., by=c( \"trait\", \"strain\", \"marker\") ) # join to phenotypes\n  \n  # calculate variance explained using spearman correlation\n  cors <- gINFO %>%\n    # each significant snp contains genotype and phenotype information for all strains\n    # so group by both to calculate variance explained for each significant snp\n    dplyr::group_by( trait, marker ) %>% \n    # calculate correlation\n    dplyr::mutate( var.exp = cor(value, allele, use = \"pairwise.complete.obs\", method=\"spearman\")^2 )  \n  \n  # bring it all together, that :\n  # # # genotypes\n  # # # phenotypes\n  # # # correlations\n  # # # # # # # # # # # FOR ALL SIGNIFICANT SNPS\n  \n  CORmaps <- Processed %>%\n    dplyr::left_join( ., cors, by=c(\"trait\",\"marker\",\"CHROM\",\"POS\"), copy=TRUE )\n  \n  processed_mapping_df <- Processed\n  correlation_df <- CORmaps\n  \n  # # # Part 2\n  \n  \n  # # # IDENTIFY PEAKS\n  \n  # PHENOTYPES THAT HAVE SIGNIFICANT MAPPINGS\n  phenotypes <- as.character(unique(processed_mapping_df$trait))\n  \n  # INITIALIZE A LIST TO PUT INDIVIDUAL PHENOTYPE INTERVAL INFORMATION\n  intervals <- list()\n  \n  # LOOP THROUGH ALL UNIQUE PHENOTYPES\n  for( i in 1:length(phenotypes) ){\n    \n    print(paste(100*signif(i/length(phenotypes),3), \"%\",sep=\"\"))\n    \n    # PREP DATA FRAME FOR PEAK IDENTIFICATION\n    \n    PeakDF <- processed_mapping_df %>%\n      dplyr::filter( trait == phenotypes[i] ) %>%\n      dplyr::group_by( CHROM, trait ) %>%\n      dplyr::mutate( index = 1:n() ) %>% # SNP INDEX\n      dplyr::mutate( peaks = cumsum(aboveBF) ) %>% # IDENTIFY PEAKS\n      dplyr::filter( aboveBF == 1 )%>% # KEEP SNPS ABOVE BONFERRONI\n      dplyr::group_by( CHROM, trait) %>%\n      dplyr::mutate( nBF = n() ) %>% # COUNT NUMBER OF SNPS ABOVE BONFERRONI PER PHENOTYPE PER CHROMOSOME\n      dplyr::group_by( CHROM, trait ) %>% \n      dplyr::arrange( CHROM, POS ) # ARRANGE DATA BY CHROMOSOME AND POSITION\n    \n    # generate a SNP index for SNPs on each chromosome\n    SNPindex <- processed_mapping_df %>%\n      dplyr::filter( trait == phenotypes[i] ) %>%\n      dplyr::group_by( CHROM, trait ) %>%\n      dplyr::mutate( index = 1:n() )%>%\n      dplyr::distinct( CHROM, POS )%>%\n      dplyr::select( CHROM, POS, index )%>%\n      dplyr::filter( POS == min(POS) | POS == max(POS) )\n    \n    # FILTER COMPLETE DATA SET TO JUST LOOK AT ONE PHENOTYPE AT A TIME\n    findPks <- PeakDF %>%\n      dplyr::filter( trait == phenotypes[i] ) %>% \n      dplyr::group_by( CHROM ) %>% \n      dplyr::arrange( CHROM, POS )\n    \n    # IF ONLY ONE SNP PASSED SIGNIFICANCE THRESHOLD LABEL PEAK ID AS 1\n    if ( findPks$nBF == 1 & length(unique(findPks$CHROM) ) == 1 ){\n      \n      findPks$pID <- 1\n      \n      # PLUS / MINUS 50 SNPS FROM PEAK SNP DEFINES CONFIDENCE INTERVAL\n      findPks <- findPks %>%\n        dplyr::group_by( CHROM, pID, trait ) %>%\n        dplyr::mutate( start = min(index) - CI_size,\n                       end = max(index) + CI_size )\n      \n      for( k in 1:nrow(findPks) ){\n        \n        tSNPs <- SNPindex %>%\n          dplyr::filter( CHROM == findPks$CHROM[k] )\n        \n        if( findPks$start[k] < min(tSNPs$index) ){\n          \n          findPks$start[k] <- min(tSNPs$index)\n          \n        } else if( findPks$end[k] > max(tSNPs$index) ) {\n          \n          findPks$end[k] <- max(tSNPs$index)\n          \n        }\n      }\n      \n      # APPEND TO LIST\n      intervals[[i]] <- findPks %>%\n        dplyr::ungroup()\n      \n    } \n    else \n    {\n      # INITIALIZE PEAK ID COLUMN WITH 1'S :: GIVES YOU A STARTING POINT\n      findPks$pID <- 1\n      \n      # LOOP THROUGH ROWS FOR EACH PHENOTYPE CORRESPONDING TO SNPS ABOVE BONFERRONI CORRECTION\n      # START AT ROW 2 BECAUSE THERE WILL ALWAYS BE AT LEAST 1 UNIQUE PEAK\n      for( j in 2:nrow(findPks) ){\n        \n        # IF \n        # SNP INDEX IS WITHIN A CERTAIN RANGE (snp_grouping) OF SNP FROM PREVIOUS ROW\n        # AND\n        # ON THE SAME CHROMOSOME AS SNP FROM PREVIOUS ROW\n        # # # # CONSIDER THEM TO BE THE SAME PEAK\n        \n        # IF THE ABOVE CONDITIONS ARE NOT MET\n        # ADD 1 TO THE PEAK ID (i.e. IDENTIFY AS A NEW PEAK)\n        findPks$pID[j] <- ifelse( abs(findPks$index[j] - findPks$index[j-1]) < snp_grouping &\n                                    findPks$CHROM[j] == findPks$CHROM[j-1],\n                                  findPks$pID[j-1],\n                                  findPks$pID[j-1]+1)\n      }\n      \n      # PLUS / MINUS 50 SNPS FROM PEAK SNP DEFINES CONFIDENCE INTERVAL\n      findPks <- findPks %>%\n        dplyr::group_by( CHROM , pID, trait) %>%\n        dplyr::mutate(start = min(index) - CI_size,\n                      end = max(index) + CI_size)\n      \n      \n      for( k in 1:nrow(findPks) ){\n        \n        tSNPs <- SNPindex %>%\n          dplyr::filter( CHROM == findPks$CHROM[k] )\n        \n        if( findPks$start[k] < min(tSNPs$index) ){\n          \n          findPks$start[k] <- min(tSNPs$index)\n          \n        } else if( findPks$end[k] > max(tSNPs$index) ) {\n          \n          findPks$end[k] <- max(tSNPs$index)\n          \n        }\n      } \n      \n      \n    }\n    \n    # APPEND TO LIST\n    intervals[[i]] <- findPks %>% \n      dplyr::ungroup()\n    \n  }\n  # BIND GENERATED LIST TOGETHER \n  intervalDF <- data.table::rbindlist(intervals)\n  \n  peak_df <- intervalDF\n  peak_list <- intervals\n  \n  # FILTER COMPLETE MAPPING SET TO ONLY CONTAIN INTERVAL INDICIES TO SAVE COMPUTATIONAL TIME BELOW\n  Pos_Index_Reference  <- processed_mapping_df %>%\n    dplyr::group_by( CHROM, trait ) %>%\n    dplyr::mutate( index = 1:n() ) %>%\n    dplyr::mutate( peaks = cumsum(aboveBF) ) %>%\n    dplyr::select( trait, CHROM, POS, index ) %>%\n    dplyr::filter( index %in% c(unique(peak_df$start), unique(peak_df$end)) ) %>%\n    dplyr::ungroup()\n  \n  Pos_Index_Reference$trait <- as.character(Pos_Index_Reference$trait)\n  \n  # INITIALIZE LIST TO APPEND INTERVAL POSITION DATA FOR EACH PHENOTYPE\n  interval_positions <- list()\n  \n  # LOOP THROUGH UNIQUE PHENOTYPES TO LINK CONFIDENCE INTERVALS IN INDEX FORM TO POSITION FORM\n  for( i in 1:length(peak_list)){\n    \n    print(paste(100*signif(i/length(peak_list),3), \"%\",sep=\"\"))\n    \n    peak_list[[i]]$trait <- as.character(peak_list[[i]]$trait)\n    \n    # FILTER TO LOOK AT ONE PHENOTYPE AT A TIME\n    # FILTER APPROPRIATE INTERVAL INDICIES AND CHROMOSOMES FOR THAT PHENOTYPE\n    trait_i <- unique(peak_list[[i]]$trait)\n    index_i <- c(peak_list[[i]]$start, peak_list[[i]]$end) \n    CHROM_i <- peak_list[[i]]$CHROM\n    \n    PKpos <- data.frame(Pos_Index_Reference) %>%\n      dplyr::filter(trait == trait_i &\n                      index %in% index_i &\n                      CHROM %in%  CHROM_i) %>%\n      # JOIN POSITION INFORMATION TO PHENOTYPE PEAK INFORMATION\n      dplyr::left_join( ., peak_list[[i]], by= c(\"trait\",\"CHROM\") )%>%\n      # YOU WILL GET UNWANTED SNP INDEX INFORMATION IN SITUATIONS WHERE YOU HAVE MULTIPLE PEAKS \n      # ELIMINATE THOSE BY MATCHING START AND END FROM INDEX DATAFRAME TO INDEX FROM POSITION DATAFRAME\n      # FIRST FLAG\n      dplyr::mutate(issues = ifelse(start == index.x | end == index.x, 1, 0))%>%\n      # THEN REMOVE\n      dplyr::filter(issues != 0)%>%\n      # SELECT COLUMNS OF INTEREST\n      dplyr::select(trait, CHROM, POS.x, POS.y, pID, log10p, index.x, index.y, start, end)%>%\n      # GROUP BY PEAK IDS ORIGINALLY PRESENT IN INDEX DATAFRAME\n      dplyr::group_by(CHROM, pID) %>%\n      # GENERATE COLUMNS TO WITH INTERVAL POSITIONS AND PEAK POSITIONS\n      dplyr::mutate(startPOS = min(POS.x),\n                    peakPOS = POS.y,\n                    endPOS = max(POS.x)) %>%\n      # ELIMINATE REDUNDANT DATA\n      dplyr::distinct(trait, CHROM, pID, peakPOS) %>%\n      # SELECT COLUMNS OF NTEREST\n      dplyr::select(trait, CHROM, POS = POS.y, startPOS, peakPOS, endPOS, peak_id = pID)\n    \n    # APPEND TO LIST\n    interval_positions[[i]] <- PKpos\n  }\n  \n  # BIND EVERYTHING\n  interval_pos_df <- data.frame(data.table::rbindlist(interval_positions)) %>%\n    # CALCULATE INTERVAL SIZE\n    dplyr::mutate(interval_size = endPOS - startPOS)\n  \n  # JOIN INTERVAL POSITIONS TO DATA FRAME CONTAINING CORRELATION INFORMATION AND PHENOTYPE INFORMATION\n  Final_Processed_Mappings <- dplyr::left_join( correlation_df, interval_pos_df, \n                                                by = c(\"trait\", \"CHROM\", \"POS\"),\n                                                copy = TRUE )\n  \n  return(Final_Processed_Mappings)\n  \n}\n\n# variant_correlation <- function(df, \n#                                 quantile_cutoff_high = .9, \n#                                 quantile_cutoff_low = .1,\n#                                 genomicTrait = F){\n#   \n#   \n#   if(genomicTrait == T){\n#     # loosely identify unique QTL identified in mappings.\n#     intervals <- df %>%\n#       na.omit() %>%\n#       dplyr::distinct(CHROM, startPOS, endPOS ) %>%\n#       dplyr::distinct(CHROM, startPOS ) %>%\n#       dplyr::distinct(CHROM, endPOS ) %>%\n#       dplyr::arrange(CHROM, startPOS) \n#   } else {\n#     # loosely identify unique QTL identified in mappings.\n#     intervals <- df %>%\n#       na.omit() %>%\n#       dplyr::distinct(condition, CHROM, startPOS, endPOS ) %>%\n#       dplyr::distinct(CHROM, startPOS ) %>%\n#       dplyr::distinct(CHROM, endPOS ) %>%\n#       dplyr::arrange(CHROM, startPOS) \n#   }\n#   \n#   \n#   # unique strains to filter snpeff output for GWAS data - doesnt matter for genomic traits\n#   strains <- as.character(na.omit(unique(df$strain)))\n#   # set up the database to search for gene annotations using the biomart package\n#   ensembl = biomaRt::useMart(\"ensembl\",dataset=\"celegans_gene_ensembl\")\n#   \n#   # initialize a list to store gene annotations for genes most highly correlated with phenotype\n#   intervalGENES <- list()\n#   \n#   # loop through all unique intervals\n#   for( i in 1:nrow(intervals)){\n#     \n#     print(paste(100*signif(i/nrow(intervals),3), \"%\",sep=\"\"))\n#     \n#     \n#     nstrains <- df %>%\n#       dplyr::filter( trait == intervals[i,]$trait ) %>%\n#       na.omit()\n#     \n#     nstrains <- length(unique(nstrains$strain))\n#     \n#     # define chromosome and left and right bound for intervals\n#     CHROM <- as.character(intervals[i,]$CHROM)\n#     left <- intervals[i,]$startPOS\n#     right <- intervals[i,]$endPOS\n#     \n#     # define region of interest for Dan's snpeff function input\n#     region_of_interest <- paste0(CHROM,\":\",left,\"-\",right)\n#     \n#     # run variant effect prediction function\n#     snpeff_output <- snpeff(region = region_of_interest, impute = F) \n#     \n#     # prune snpeff outputs\n#     pruned_snpeff_output <- snpeff_output %>%\n#       dplyr::filter( strain %in% strains ) %>% # only keep strains used in mappings\n#       dplyr::filter( !is.na(impact) ) %>% # remove rows with NA in impact (looked to be mostly splice variants)\n#       dplyr::distinct( CHROM, POS, strain, effect, gene_id ) %>% # remove duplicates\n#       dplyr::arrange( effect ) %>% \n#       # pull out columns of interest\n#       dplyr::select( CHROM, POS, REF, ALT, GT, effect, \n#                      nt_change, aa_change, gene_name, \n#                      gene_id, feature_type, strain) %>%\n#       dplyr::group_by( CHROM, POS, effect) %>% # group for individual genes and effects\n#       # make numeric allele column, this makes HETs and NAs in the GT column NAs - these are excluded from the correlation analysis\n#       # need to elimante hets and NAs from GT\n#       dplyr::filter(!is.na(GT), GT != \"HET\")%>%\n#       # make numeric\n#       dplyr::mutate(num_allele = ifelse(GT == \"REF\", 0, \n#                                         ifelse(GT == \"ALT\", 1, NA)))%>%\n#       # determine if any alleles are present in less that 5% of the population\n#       dplyr::mutate(num_alt_allele = sum(num_allele, na.rm=T),\n#                     num_strains = n())%>%\n#       # if they are, eliminate\n#       dplyr::filter(num_alt_allele / num_strains > .05) %>%\n#       dplyr::filter(num_strains > nstrains*.8)\n#     \n#     if( nrow(pruned_snpeff_output) > 0 ){\n#       # pull unique interval from processed mapping DF to recover, phenotypes, strains, log10p, phenotype value\n#       # this is useful to pull out all intervals with the same confidence interval that were pruned above.\n#       interval_df <- df %>%\n#         dplyr::filter( CHROM == CHROM, startPOS == left, endPOS = right )%>% # filter for confidence interval of interest\n#         dplyr::group_by( trait, CHROM, startPOS,endPOS ) %>% # group by unique phenotype and interval\n#         dplyr::filter( log10p == max(log10p) ) %>% # pull out most significant snp to minimize redundancy\n#         dplyr::distinct( trait, startPOS, endPOS, peakPOS, strain) %>% \n#         dplyr::select( trait, startPOS, endPOS, peakPOS, strain, log10p, CHROM, pheno_value = value)\n#       \n#       # calculate the correlation between interval variants and the phenotype \n#       # pull out only the most correlated genes \n#       \n#       pheno_snpeff_df <- pruned_snpeff_output %>%\n#         dplyr::left_join(., interval_df, by = \"strain\", copy = TRUE) %>% # join snpeff variant df to phenotype df for a particular interval\n#         dplyr::distinct( strain, trait, pheno_value, gene_name) %>% # remove redundancy\n#         dplyr::group_by( trait, CHROM, POS, effect, feature_type) %>% # group_by unique variant and phenotype\n#         dplyr::mutate(spearman_cor = cor(pheno_value, num_allele, method = \"spearman\", use = \"pairwise.complete.obs\"))%>% # calculate correlation\n#         dplyr::ungroup()%>% # ungroup to calculate quantiles of correlations\n#         # dplyr::mutate(q90 = quantile(spearman_cor, probs = .9, na.rm = T) )%>%\n#         # we want to keep high positively correlated and high negatively correlated variants\n#         dplyr::mutate(abs_spearman_cor = abs(spearman_cor))%>%\n#         dplyr::filter(abs_spearman_cor > quantile(abs_spearman_cor, probs = quantile_cutoff_high, na.rm = T) )%>%\n#         dplyr::ungroup()%>%\n#         # organize DF by correlation\n#         dplyr::arrange(desc(abs_spearman_cor))\n#       \n#       \n#       # get gene annotations usining biomart package\n#       # attributes are the columns you want to return\n#       # filters are the columns you want to filter by, in this case we want to filter by wormbase_gene - e.g. WBGene00012953\n#       # values are the values you want to be present in the filter column, i.e the genes you want information from\n#       # this is pulled from the highly correlated variant DF above\n#       # mart is defined above as the annoted c.elegans genome\n#       gene_annotations <- getBM(attributes=c('entrezgene','go_id',\"external_gene_name\",\n#                                              \"external_transcript_name\",\"gene_biotype\",\n#                                              \"transcript_biotype\",\"description\", \"family_description\",\n#                                              \"name_1006\",\"wormbase_gene\"), \n#                                 filters = \"wormbase_gene\",\n#                                 values = unique(pheno_snpeff_df$gene_id),\n#                                 mart=ensembl) %>%\n#         dplyr::distinct(entrezgene, go_id) %>% # pu;; distinct genes\n#         dplyr::rename(gene_id = wormbase_gene) # change column for joining\n#       \n#       # attach the correlation coefficient to gene annotation data frame to minimize looking at multiple data frames\n#       gene_cors <- pheno_snpeff_df %>%\n#         dplyr::select(gene_id, spearman_cor)%>%\n#         dplyr::distinct(gene_id, spearman_cor) %>%\n#         dplyr::left_join(gene_annotations, ., by = \"gene_id\") %>%\n#         dplyr::arrange(desc(spearman_cor))\n#       \n#       # append phenotype-snpeff-correlation DF and gene annotation DF to list for every unique interval\n#       intervalGENES[[i]] <- list(pheno_snpeff_df, gene_cors)\n#     } \n#     else\n#     {\n#       intervalGENES[[i]] <- list(NA, NA)\n#     }\n#     \n#   }\n#   \n#   return(intervalGENES)\n# }\n\n# called functions - from Dan Cook\n\n# snpeff <- function(region = \"II:14524173..14525111\",\n#                    severity = c(\"HIGH\",\"MODERATE\"),\n#                    long = TRUE,\n#                    impute = TRUE) {\n#   \n#   if (impute == T) {\n#     vcf_file = \"20150731_WI_PASS.impute.snpeff.vcf.gz\"\n#   } else {\n#     vcf_file = \"20150731_WI_PASS.snpeff.vcf.gz\"\n#   }\n#   \n#   \n#   \n#   if (!grepl(\"(I|II|III|IV|V|X|MtDNA).*\", region)) {\n#     gene_ids <- read_tsv(\"~/Dropbox/Andersenlab/WormReagents/Variation/Andersen_VCF/wb_gene.txt\")\n#     wb_id <- filter(gene_ids, name == region)$ID\n#     wb_url <- paste0(\"http://api.wormbase.org/rest/field/gene/\",wb_id, \"/location/\")\n#     wb_ret <- GET(wb_url, add_headers(\"Content-Type\"=\"application/json\"))\n#     region <- content(wb_ret)$location$genomic_position$data[[1]]$pos_string\n#   } \n#   \n#   # Fix region to allow wb type spec.\n#   region <- gsub(\"\\\\.\\\\.\", \"-\", region)\n#   \n#   script_dir <- list.dirs(\"~/Dropbox/Andersenlab/WormReagents/Variation/Andersen_VCF/\")[[1]]\n#   command <- paste(\"python\",\n#                    \"~/Dropbox/Andersenlab/WormReagents/Variation/Andersen_VCF/query.py\", \n#                    region,\n#                    paste0(script_dir,vcf_file),\n#                    paste(severity, collapse=\",\"))\n#   \n#   tsv <- read_tsv( pipe(command), na = \"None\") \n#   if (long == FALSE) {\n#     tsv\n#   } else {\n#     tsv <- gather_(tsv, \"strain\", \"GT\", names(tsv)[21:length(tsv)])  %>%\n#       tidyr::separate(GT, into=c(\"a1\",\"a2\"), sep=\"/|\\\\|\", remove=T) %>%\n#       dplyr::mutate(a1=ifelse(a1 == \".\", NA, a1)) %>%\n#       dplyr::mutate(a2=ifelse(a2 == \".\", NA, a2)) %>%\n#       dplyr::mutate(GT = NA) %>%\n#       dplyr::mutate(GT = ifelse(a1 == REF & a2 == REF & !is.na(a1), \"REF\",GT)) %>%\n#       dplyr::mutate(GT = ifelse(a1 != a2 & !is.na(a1), \"HET\",GT)) %>%\n#       dplyr::mutate(GT = ifelse(a1 == a2 & a1 != REF & !is.na(a1), \"ALT\",GT)) %>%\n#       dplyr::select(CHROM, POS, strain, REF, ALT, a1, a2, GT, everything()) %>%\n#       dplyr::arrange(CHROM, POS) \n#     \n#     tsv\n#   }\n# }\n\n",
    "created" : 1440102870113.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "117|46|254|0|\n274|43|348|0|\n",
    "hash" : "1636408825",
    "id" : "89A910A1",
    "lastKnownWriteTime" : 1440112012,
    "path" : "~/Dropbox/AndersenLab/RCode/GWAS/cegwas/R/process_mappings.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}